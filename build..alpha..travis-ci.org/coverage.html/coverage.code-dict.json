{"/home/travis/build/npmtest/node-npmtest-jsgraph/test.js":"/* istanbul instrument in package npmtest_jsgraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsgraph/lib.npmtest_jsgraph.js":"/* istanbul instrument in package npmtest_jsgraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsgraph = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsgraph = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsgraph/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsgraph && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsgraph */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsgraph\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsgraph.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsgraph.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsgraph.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsgraph.__dirname + '/lib.npmtest_jsgraph.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_graph.js":"/* --------------------------------------------------------------------------\n\n   The MIT License (MIT)\n\n   Copyright (c) 2014-2016 Christopher D. Russell\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n  This library is part of the Encapsule Project System in Cloud (SiC) open service\n  architecture. Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things with in-memory\n  data on Node.js and HTML.  https://github.com/encapsule http://blog.encapsule.org\n\n-------------------------------------------------------------------------- */\n\nvar jsgraph = module.exports = {\n\n    // Directed graph support\n    directed: {\n\n        ////\n        // Create a DirectedGraph container object.\n        //\n        // var response = jsgraph.directed.create(request);\n        //\n        // request = Undefined, JSON string, or data object [1]\n        //\n        // response = {\n        //     error: null or string explaining why result is null\n        //     result: DirectedGraph container object or null if error\n        // }\n        //\n        // Notes:\n        //\n        // [1] see DirectedGraph.toJSON/toObject methods.\n        //\n        ////\n        create: require('./arc_core_digraph').createDirectedGraph,\n\n        // Directed graph transposition algorithm.\n        // Creates a new DirectedGraph container object that's identical\n        // to a caller-specified digraph except that the direction of the\n        // the edges are reverese in the result digraph. Note that if present,\n        // vertex and edge properties in the source digraph are copied by\n        // reference to the result digraph.\n        transpose: require('./arc_core_digraph_algorithm_transpose'),\n\n        // Directed graph breadth-first traversal visitor algorithm.\n        breadthFirstTraverse: require('./arc_core_digraph_algorithm_bft'),\n\n        // Directed graph depth-first traversal visitor algorithm.\n        depthFirstTraverse: require('./arc_core_digraph_algorithm_dft'),\n\n        // ADVANCED\n\n        // Color constant hashtable (advanced).\n        colors: require('./arc_core_digraph_algorithm_colors'),\n\n        // Directed graph traversal context factory (advanced).\n        createTraversalContext: require('./arc_core_digraph_algorithm_context')\n\n    }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n// Inspired by the Boost Graph Library (BGL)\n// http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html\n// http://en.wikipedia.org/wiki/Directed_graph\n\nvar helperFunctions = require('./arc_core_graph_util');\nvar digraphParams = require('./arc_core_digraph_in_params');\nvar digraphImport = require('./arc_core_digraph_import');\nvar digraphExport = require('./arc_core_digraph_export');\n\n(function() {\n    var __bind = function(method, scope){ return function(){ return method.apply(scope, arguments); }; };\n\n    var DirectedGraph = (function() {\n        function DirectedGraph(jsonOrObject_) {\n\n            // Meta methods\n            this.getGraphName = __bind(this.getGraphName, this);\n            this.setGraphName = __bind(this.setGraphName, this);\n            this.getGraphDescription = __bind(this.getGraphDescription, this);\n            this.setGraphDescription = __bind(this.setGraphDescription, this);\n\n            // Vertex-scope methods\n            this.isVertex = __bind(this.isVertex, this);\n            this.addVertex = __bind(this.addVertex, this);\n            this.removeVertex = __bind(this.removeVertex, this);\n            this.getVertexProperty = __bind(this.getVertexProperty, this);\n            this.setVertexProperty = __bind(this.setVertexProperty, this);\n            this.hasVertexProperty = __bind(this.hasVertexProperty, this);\n            this.clearVertexProperty = __bind(this.clearVertexProperty, this);\n            this.inDegree = __bind(this.inDegree, this);\n            this.inEdges = __bind(this.inEdges, this);\n            this.outDegree = __bind(this.outDegree, this);\n            this.outEdges = __bind(this.outEdges, this);\n\n            // Edge-scope methods\n            this.isEdge = __bind(this.isEdge, this);\n            this.addEdge = __bind(this.addEdge, this);\n            this.removeEdge = __bind(this.removeEdge, this);\n            this.getEdgeProperty = __bind(this.getEdgeProperty, this);\n            this.setEdgeProperty = __bind(this.setEdgeProperty, this);\n            this.hasEdgeProperty = __bind(this.hasEdgeProperty, this);\n            this.clearEdgeProperty = __bind(this.clearEdgeProperty, this);\n\n            // Digraph-scope methods\n            this.verticesCount = __bind(this.verticesCount, this);\n            this.getVertices = __bind(this.getVertices, this);\n            this.edgesCount = __bind(this.edgesCount, this);\n            this.getEdges = __bind(this.getEdges, this);\n            this.rootVerticesCount = __bind(this.rootVerticesCount, this);\n            this.getRootVertices = __bind(this.getRootVertices, this);\n            this.leafVerticesCount = __bind(this.leafVerticesCount, this);\n            this.getLeafVertices = __bind(this.getLeafVertices, this);\n            this.toJSON = __bind(this.toJSON, this);\n            this.toObject = __bind(this.toObject, this);\n            this.stringify = __bind(this.stringify, this);\n            this.fromObject = __bind(this.fromObject, this);\n            this.fromJSON = __bind(this.fromJSON, this);\n\n            // DirectedGraph container private runtime state.\n            this._private = {\n                name: \"\",\n                description: \"\",\n                vertexMap: {},\n                rootMap: {},\n                leafMap: {},\n                edgeCount: 0,\n                constructionError: null\n            };\n            if ((jsonOrObject_ !== null) && jsonOrObject_) {\n                var innerResponse = digraphImport(this, jsonOrObject_);\n                if (innerResponse.error) {\n                    this._private.constructionError = \"DirectedGraph constructor failed: \" + innerResponse.error;\n                }\n            }\n        }\n\n        // META METHODS\n\n        DirectedGraph.prototype.getGraphName = function() {\n            return this._private.name;\n        };\n\n        DirectedGraph.prototype.setGraphName = function(string_) {\n            var response = { error: null, result: null };\n            if (helperFunctions.JSType(string_) === '[object String]') {\n                this._private.name = string_;\n                response.result = true;\n            } else {\n                response.error = \"Invalid graph name specified. Expected '[object String]'.\";\n            }\n            return response;\n        };\n\n        DirectedGraph.prototype.getGraphDescription = function() {\n            return this._private.description;\n        };\n\n        DirectedGraph.prototype.setGraphDescription = function(string_) {\n            var response = { error: null, result: null };\n            if (helperFunctions.JSType(string_) === '[object String]') {\n                this._private.description = string_;\n                response.result = true;\n            } else {\n                response.error = \"Invalid graph name specified. Expected '[object String]'.\";\n            }\n            return response;\n        };\n\n        // VERTEX-SCOPE METHODS\n\n        DirectedGraph.prototype.isVertex = function (vertexId_) {\n            var innerResponse = digraphParams.verifyVertexReadRequest(vertexId_);\n            if (innerResponse.error) {\n                return false;\n            }\n            var vertex = this._private.vertexMap[vertexId_];\n            return (vertex !== null) && vertex && true || false;\n        };\n\n        /*\n          request = {\n              u: vertex ID string\n              p: optional property (must be serializable to JSON)\n          }\n          response = {\n              error: null or error string\n              result: vertex ID string or null if error\n          }\n         */\n        DirectedGraph.prototype.addVertex = function (request_) {\n            var response = { error: null, result: null };\n            var errors = [];\n            var inBreakScope = false;\n            while (!inBreakScope) {\n                inBreakScope = true;\n                var innerResponse = digraphParams.verifyVertexWriteRequest(request_);\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                var vertex = this._private.vertexMap[request_.u];\n                if ((vertex === null) || !vertex) {\n                    vertex = this._private.vertexMap[request_.u] = {};\n                    vertex.edges = {};\n                    vertex.edges.in = {};\n                    vertex.edges.out = {};\n                    this._private.rootMap[request_.u] = {};\n                    this._private.leafMap[request_.u] = {};\n                }\n                if (helperFunctions.JSType(request_.p) !== '[object Undefined]') {\n                    vertex.properties = request_.p;\n                }\n                response.result = request_.u;\n            } // end while !inBreakScope\n            if (errors.length) {\n                errors.unshift(\"DirectedGraph.addVertex failed:\");\n                response.error = errors.join(' ');\n            }\n            return response;\n        };\n\n        DirectedGraph.prototype.removeVertex = function (vertexId_) {\n            var innerResponse = digraphParams.verifyVertexReadRequest(vertexId_);\n            if (innerResponse.error) {\n                return false;\n            }\n            var vertexU = this._private.vertexMap[vertexId_];\n            if ((vertexU === null) || !vertexU) {\n                return false;\n            }\n            var vertexIdX;\n            for (vertexIdX in vertexU.edges.out) {\n                this.removeEdge({ u: vertexId_, v: vertexIdX});\n            }\n            for (vertexIdX in vertexU.edges.in) {\n                this.removeEdge({ u: vertexIdX, v: vertexId_});\n            }\n            delete this._private.vertexMap[vertexId_];\n            delete this._private.rootMap[vertexId_];\n            delete this._private.leafMap[vertexId_];\n            return true;\n        };\n\n        DirectedGraph.prototype.getVertexProperty = function(vertexId_) {\n            if (!this.isVertex(vertexId_)) {\n                return void 0;\n            }\n            return this._private.vertexMap[vertexId_].properties;\n        };\n\n        /*\n          request = {\n              u: vertex ID string\n              p: optional property (must be serializable to JSON)\n          }\n          response = {\n              error: null or error string\n              result: vertex ID string or null if error\n          }\n         */\n        DirectedGraph.prototype.setVertexProperty = function(request_) {\n            return this.addVertex(request_);\n        };\n\n        DirectedGraph.prototype.hasVertexProperty = function(vertexId_) {\n            if (!this.isVertex(vertexId_)) {\n                return false;\n            }\n            if (helperFunctions.JSType(this._private.vertexMap[vertexId_].properties) === '[object Undefined]') {\n                return false;\n            }\n            return true;\n        };\n\n        DirectedGraph.prototype.clearVertexProperty = function(vertexId_) {\n            if (!this.isVertex(vertexId_)) {\n                return false;\n            }\n            delete this._private.vertexMap[vertexId_].properties;\n            return true;\n        };\n\n        DirectedGraph.prototype.inDegree = function (vertexId_) {\n            return this.isVertex(vertexId_)?Object.keys(this._private.vertexMap[vertexId_].edges.in).length:-1;\n        };\n\n        DirectedGraph.prototype.inEdges = function(vertexId_) {\n            var result = [];\n            if (this.isVertex(vertexId_)) {\n                for (var vertexIdV in this._private.vertexMap[vertexId_].edges.in) {\n                    result.push({ u: vertexIdV, v: vertexId_});\n                }\n            }\n            return result;\n        };\n\n        DirectedGraph.prototype.outDegree = function (vertexId_) {\n            return this.isVertex(vertexId_)?Object.keys(this._private.vertexMap[vertexId_].edges.out).length:-1;\n        };\n\n        DirectedGraph.prototype.outEdges = function(vertexId_) {\n            var result = [];\n            if (this.isVertex(vertexId_)) {\n                for (var vertexIdV in this._private.vertexMap[vertexId_].edges.out) {\n                    result.push({ u: vertexId_, v: vertexIdV});\n                }\n            }\n            return result;\n        };\n\n        // EDGE-SCOPE METHODS\n\n        /*\n          request = {\n              u: string,\n              v: string,\n          }\n          response = Boolean true if edge exists. Otherwise, false.\n          Note that invalid requests are coalesced as negative responses.\n        */\n        DirectedGraph.prototype.isEdge = function(request_) {\n            var response = false;\n            var inBreakScope = false;\n            while (!inBreakScope) {\n                inBreakScope = true;\n                if (digraphParams.verifyEdgeReadRequest(request_).error) {\n                    break;\n                }\n                var vertexU = this._private.vertexMap[request_.u];\n                var vertexV = this._private.vertexMap[request_.v];\n                if (!((vertexU !== null) && vertexU && (vertexV !== null) && vertexV)) {\n                    break;\n                }\n                var edge = vertexU.edges.out[request_.v];\n                response = (edge !== null) && edge && true || false;\n            }\n            return response;\n        };\n\n        /*\n          request = {\n              e: { u: string, v: string },\n              p: (optional) property serializable to JSON\n          }\n          response = {\n              error: error string or null\n              result: edge descriptor object or null iff error\n          }\n         */\n        DirectedGraph.prototype.addEdge = function (request_) {\n            var response = { error: null, result: null };\n            var errors = [];\n            var inBreakScope = false;\n            while (!inBreakScope) {\n                inBreakScope = true;\n                var innerResponse = digraphParams.verifyEdgeWriteRequest(request_);\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                innerResponse = this.addVertex({ u: request_.e.u });\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                innerResponse = this.addVertex({ u: request_.e.v });\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                var outEdge = this._private.vertexMap[request_.e.u].edges.out[request_.e.v];\n                if ((outEdge === null) || !outEdge) {\n                    outEdge = this._private.vertexMap[request_.e.u].edges.out[request_.e.v] = {};\n                    delete this._private.leafMap[request_.e.u];\n                }\n                var inEdge = this._private.vertexMap[request_.e.v].edges.in[request_.e.u];\n                if ((inEdge === null) || !inEdge) {\n                    inEdge = this._private.vertexMap[request_.e.v].edges.in[request_.e.u] = {};\n                    this._private.edgeCount++;\n                    delete this._private.rootMap[request_.e.v];\n                }\n                if (helperFunctions.JSType(request_.p) !== '[object Undefined]') {\n                    outEdge.properties = request_.p;\n                }\n                response.result = request_.e;\n            } // end while !inBreakScope\n            if (errors.length) {\n                errors.unshift(\"DirectedGraph.addEdge failed:\");\n                response.error = errors.join(' ');\n            }\n            return response;\n        };\n\n        /*\n          request = {\n              u: string,\n              v: string,\n          }\n          response = {\n              error: null or error string explaining why result is null\n              result: Boolean true if successful. False if edge doesn't exist.\n          }\n        */\n        DirectedGraph.prototype.removeEdge = function(request_) {\n            var response = { error: null, result: null };\n            var errors = [];\n            var inBreakScope = false;\n            while (!inBreakScope) {\n                inBreakScope = true;\n                var innerResponse = digraphParams.verifyEdgeReadRequest(request_);\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                var vertexU = this._private.vertexMap[request_.u];\n                var vertexV = this._private.vertexMap[request_.v];\n                if (!((vertexU !== null) && vertexU && (vertexV !== null) && vertexV)) {\n                    response.result = false;\n                    break;\n                }\n                var outEdgeMap = vertexU.edges.out;\n                var edge = outEdgeMap[request_.v];\n                if (!((edge !== null) && edge)) {\n                    response.result = false;\n                    break;\n                }\n                delete outEdgeMap[request_.v];\n                if (!Object.keys(outEdgeMap).length) {\n                    this._private.leafMap[request_.u] = {};\n                }\n                var inEdgeMap = vertexV.edges.in;\n                delete inEdgeMap[request_.u];\n                if (!Object.keys(inEdgeMap).length) {\n                    this._private.rootMap[request_.v] = {};\n                }\n                if (this._private.edgeCount) {\n                    this._private.edgeCount--;\n                }\n                response.result = true;\n            } // while !inBreakScope\n            if (errors.length) {\n                errors.unshift(\"DirectedGraph.removeEdge failed:\");\n                response.error = errors.join(' ');\n            }\n            return response;\n        };\n\n        /*\n          request = {\n              u: string,\n              v: string\n          }\n          response = void 0 or whatever property is assigned to the edge\n          Note that build requests are coalesced to void 0 responses.\n         */\n\n        DirectedGraph.prototype.getEdgeProperty = function(request_) {\n            var response = void 0;\n            var inBreakScope = false;\n            while (!inBreakScope) {\n                inBreakScope = true;\n                if (digraphParams.verifyEdgeReadRequest(request_).error) {\n                    break;\n                }\n                var vertexU = this._private.vertexMap[request_.u];\n                var vertexV = this._private.vertexMap[request_.v];\n                if (!((vertexU !== null) && vertexU && (vertexV !== null) && vertexV)) {\n                    break;\n                }\n                response = vertexU.edges.out[request_.v].properties;\n            }\n            return response;\n        };\n\n        /*\n          request = {\n              e: { u: string, v: string },\n              p: (optional) property serializable to JSON\n          }\n          response = {\n              error: error string or null\n              result: edge descriptor object or null iff error\n          }\n         */\n        DirectedGraph.prototype.setEdgeProperty = function(request_) {\n            return this.addEdge(request_);\n        };\n\n        DirectedGraph.prototype.hasEdgeProperty = function(request_) {\n            if (!this.isEdge(request_)) {\n                return false;\n            }\n            if (helperFunctions.JSType(this._private.vertexMap[request_.u].edges.out[request_.v].properties) === '[object Undefined]') {\n                return false;\n            }\n            return true;\n        };\n\n        DirectedGraph.prototype.clearEdgeProperty = function(request_) {\n            if (!this.isEdge(request_)) {\n                return false;\n            }\n            delete this._private.vertexMap[request_.u].edges.out[request_.v].properties;\n            return true;\n        };\n\n        // DIGRAPH-SCOPE METHODS\n\n        DirectedGraph.prototype.verticesCount = function() {\n            return Object.keys(this._private.vertexMap).length;\n        };\n\n        DirectedGraph.prototype.getVertices = function() {\n            var vertices = [];\n            for (var vertexId in this._private.vertexMap) {\n                vertices.push(vertexId);\n            }\n            return vertices;\n        };\n\n        DirectedGraph.prototype.edgesCount = function() {\n            return this._private.edgeCount;\n        };\n\n        DirectedGraph.prototype.getEdges = function() {\n            var edges = [];\n            var vertices = this.getVertices();\n            var processVertexOutEdges = function(outEdges_) {\n                outEdges_.forEach(function(outEdge_) {\n                    edges.push(outEdge_);\n                });\n            };\n            var self = this;\n            vertices.forEach(function(vertexId_) {\n                processVertexOutEdges(self.outEdges(vertexId_));\n            });\n            return edges;\n        };\n\n        DirectedGraph.prototype.rootVerticesCount = function() {\n            return Object.keys(this._private.rootMap).length;\n        };\n\n        DirectedGraph.prototype.getRootVertices = function() {\n            var rootVertices = [];\n            for (var vertexId in this._private.rootMap) {\n                rootVertices.push(vertexId);\n            }\n            return rootVertices;\n        };\n\n        DirectedGraph.prototype.leafVerticesCount = function() {\n            return Object.keys(this._private.leafMap).length;\n        };\n\n        DirectedGraph.prototype.getLeafVertices = function() {\n            var leafVertices = [];\n            for (var vertexId in this._private.leafMap) {\n                leafVertices.push(vertexId);\n            }\n            return leafVertices;\n        };\n\n        // toJSON and toObject are identical delegations to digraphExport.exportObject.\n        DirectedGraph.prototype.toJSON = function () {\n            return digraphExport.exportObject(this);\n        };\n        DirectedGraph.prototype.toObject = function() {\n            return digraphExport.exportObject(this);\n        };\n\n        DirectedGraph.prototype.stringify = function(replacer_, space_) {\n            return digraphExport.exportJSON(this, replacer_, space_);\n        };\n\n        DirectedGraph.prototype.fromObject = function (object_) {\n            return digraphImport(this, object_);\n        };\n\n        DirectedGraph.prototype.fromJSON = function(json_) {\n            return digraphImport(this, json_);\n        };\n\n        return DirectedGraph;\n\n    })();\n\n    var createDirectedGraph = function (jsonOrObject_) {\n        var response = { error: null, result: null };\n        var digraph = new DirectedGraph(jsonOrObject_);\n        if (digraph._private.constructionError) {\n            response.error = digraph._private.constructionError;\n        } else {\n            response.result = digraph;\n        }\n        return response;\n    };\n\n    module.exports = {\n        /*\n          createDirectedGraph is a wrapper around JavaScript operator new jsgraph.DirectedGraph(...)\n          that returns an error/result response object. This is the preferred mechanism by which\n          jsgraph-derived client code should construct DirectedGraph container object instance(s).\n        */\n        createDirectedGraph: createDirectedGraph,\n\n        /*\n          DirectedGraph is constructed with JavaScript operator new but may fail during construction\n          if an error is encountered parsing the constructor's optional JSON/data object in-paramter.\n          After contruction, clients should check DirectedGraph.constructionError === null to ensure\n          that construction was successful. If a construction error occurred, constructionError is the\n          response.error string returned by DirectedGraph's data import subroutine.\n        */\n        DirectedGraph: DirectedGraph\n\n    };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_graph_util.js":"/*\n   Copyright (C) 2014-2016 Christopher D. Russell\n\n   This library is published under the MIT License and is part of the\n   Encapsule Project System in Cloud (SiC) open service architecture.\n   Please follow https://twitter.com/Encapsule for news and updates\n   about jsgraph and other time saving libraries that do amazing things\n   with in-memory data on Node.js and HTML.\n*/\n\nvar JSType = function(reference_) {\n    return Object.prototype.toString.call(reference_);\n};\n\n/*\n  request = {\n      ref: reference\n      types: string or array of strings (e.g. '[object Object]')\n  }\n  response = {\n      error: null (success) or string (error)\n      result: null (failure) or JSType of request.ref (success)\n  }\n\n*/\nvar JSTypeInTypeSet = function(request_) {\n    var response = { error: null, result: null };\n    var errors = [];\n    var allowedTypeSet = {};\n    var jstype = JSType(request_.types);\n    switch (jstype) {\n    case '[object String]':\n        allowedTypeSet = [ request_.types ];\n        break;\n    case '[object Array]':\n        allowedTypeSet = request_.types;\n        break;\n    default:\n        errors.unshift(\"Invalid request.types value type '\" + jstype + \"'. Expected either '[object String]' or '[object Array]'.\");\n        break;\n    }\n    jstype = JSType(request_.description);\n    if (jstype !== '[object String]') {\n        errors.unshift(\"Invalid request.description value type '\" + jstype + \"'. Expected '[object String]'.\");\n    }\n    if (!errors.length) {\n        jsType = JSType(request_.ref);\n        response.result = (allowedTypeSet.indexOf(jsType) !== -1) && jsType || null;\n    }\n    if (!response.result) {\n        response.guidance = request_.description + \" value type '\" + jstype + \"' is invalid. Expected one of [\" + allowedTypeSet.join(',') + \"].\";\n    }\n    if (errors.length) {\n        errors.unshift(\"JSTypeInTypeSet failed:\");\n        response.error = errors.join(' ');\n    }\n    return response;\n\n};\n\n var setPropertyValueIfUndefined = function(reference_, propertyName_, valueOrFunction_) {\n     var type = JSType(reference_[propertyName_]);\n    if (type === '[object Undefined]') {\n        type = JSType(valueOrFunction_);\n        if (type !== '[object Function]') {\n            reference_[propertyName_] = valueOrFunction_;\n        } else {\n            reference_[propertyName_] = valueOrFunction_();\n        }\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    JSType: JSType,\n    setPropertyValueIfUndefined: setPropertyValueIfUndefined\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_in_params.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\nvar helperFunctions = require('./arc_core_graph_util');\n\nvar verifyVertexReadRequest = function(request_) {\n    var response = { error: null, result: false };\n    var jstype = helperFunctions.JSType(request_);\n    if (jstype !== '[object String]') {\n        response.error = \"Invalid value type '\" + jstype + \"' found when expecting vertex read request. Expected '[object String]'.\";\n    } else {\n        response.result = true;\n    }\n    return response;\n};\n\nvar verifyVertexWriteRequest = function(request_) {\n    var response = { error: null, result: false };\n    var inBreakScope = false;\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var jstype = helperFunctions.JSType(request_);\n        if (jstype !== '[object Object]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found when expecting a vertex write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.u);\n        if (jstype !== '[object String]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for vertex ID string property 'u' in vertex write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.p);\n        if (jstype === '[object Function]') {\n            response.error = \"Invalid value type '\" + jstype + \" found while inspecting vertex property 'p' in vertex write request object. Must be serializable to JSON!\";\n            break;\n        }\n        response.result = true;\n    }\n    return response;\n};\n\nvar verifyEdgeReadRequest = function(request_) {\n    var response = { error: null, result: false };\n    var inBreakScope = false;\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var jstype = helperFunctions.JSType(request_);\n        if (jstype !== '[object Object]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found when expecting edge read request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.u);\n        if (jstype !== '[object String]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for vertex ID string property 'u' in edge read request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.v);\n        if (jstype !== '[object String]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for vertex ID string property 'v' in edge read request object.\";\n            break;\n        }\n        response.result = true;\n    }\n    return response;\n};\n\nvar verifyEdgeWriteRequest = function(request_) {\n    var response = { error: null, result: false };\n    var inBreakScope = false;\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var jstype = helperFunctions.JSType(request_);\n        if (jstype !== '[object Object]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found when expecting edge write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.e);\n        if (jstype !== '[object Object]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for edge descriptor object 'e' in edge write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.e.u);\n        if (jstype !== '[object String]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for vertex ID string property 'e.u' in edge write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.e.v);\n        if (jstype !== '[object String]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found looking for vertex ID string property 'e.v' in edge write request object.\";\n            break;\n        }\n        jstype = helperFunctions.JSType(request_.p);\n        if (jstype === '[object Function]') {\n            response.error = \"Invalid value type '\" + jstype + \"' found while insecting edge property 'p' in edge write request object. Must be serializable to JSON!\";\n            break;\n        }\n        response.result = true;\n    }\n    return response;\n};\n\nmodule.exports = {\n    verifyVertexReadRequest: verifyVertexReadRequest,\n    verifyVertexWriteRequest: verifyVertexWriteRequest,\n    verifyEdgeReadRequest: verifyEdgeReadRequest,\n    verifyEdgeWriteRequest: verifyEdgeWriteRequest\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_import.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\nmodule.exports = function (digraph_, jsonOrObject_) {\n\n    var jsonParse;\n    var getType = function(ref_) { return Object.prototype.toString.call(ref_); };\n    var response = { error: null, result: null };\n    var errors = [];\n    var inBreakScope = false;\n\n    var processVertex = function(vertexDescriptor_) {\n        type = getType(vertexDescriptor_);\n        if (type !== '[object Object]') {\n            errors.unshift(\"JSON semantics error: Expected vertex descriptor object in 'vlist' array but found '\" + type + \"' instead.\");\n        } else {\n            type = getType(vertexDescriptor_.u);\n            if (type !== '[object String]') {\n                errors.unshift(\"JSON semantics error: Expected vertex descriptor property 'u' to be a string but found '\" + type + \"' instead.\");\n            } else {\n                digraph_.addVertex({ u: vertexDescriptor_.u, p: vertexDescriptor_.p});\n            }\n        }\n    };\n\n    var processEdge = function (edgeDescriptor_) {\n        type = getType(edgeDescriptor_);\n        if (type !== '[object Object]') {\n            errors.unshift(\"JSON semantics error: Expected edge descriptor object in 'elist' array but found '\" + type + \"' instead.\");\n        } else {\n            type = getType(edgeDescriptor_.e);\n            if (type !== '[object Object]') {\n                errors.unshift(\"JSON semantics error: Edge record in 'elist' should define edge descriptor object 'e' but but found '\" + type + \"' instead.\");\n            } else {\n                type = getType(edgeDescriptor_.e.u);\n                if (type !== '[object String]') {\n                    errors.unshift(\"JSON semantics error: Expected edge descriptor property 'e.u' to be a string but found '\" + type + \"' instead.\");\n                } else {\n                    type = getType(edgeDescriptor_.e.v);\n                    if (type !== '[object String]') {\n                        errors.unshift(\"JSON semantics error: Expected edge descriptor property 'e.v' to be a string but found '\" + type + \"' instead.\");\n                    } else {\n                        digraph_.addEdge({ e: edgeDescriptor_.e, p: edgeDescriptor_.p});\n                    }\n                }\n            }\n        }\n    };\n\n    while (!inBreakScope) {\n        inBreakScope = true;\n\n        var type = getType(jsonOrObject_);\n        switch (type) {\n        case '[object String]':\n            try {\n                jsonParse = JSON.parse(jsonOrObject_);\n            } catch (exception_) {\n                errors.unshift(\"Exception occurred while parsing JSON: \" + exception_.message);\n            }\n            break;\n        case '[object Object]':\n            jsonParse = jsonOrObject_;\n            break;\n        default:\n            errors.unshift(\"Invalid reference to '\" + type + \"' passed instead of expected JSON (or equivalent object) reference.\");\n        }\n        if (errors.length) {\n            break;\n        }\n\n        type = getType(jsonParse);\n        if (type !== '[object Object]') {\n            errors.unshift(\"JSON semantics error: Expected top-level object but found '\" + type + \"'.\");\n            break;\n        }\n\n        type = getType(jsonParse.name);\n        switch (type) {\n        case '[object Undefined]':\n            jsonParse.name = \"\";\n            break;\n        case '[object String]':\n            break;\n        default:\n            errors.unshift(\"JSON semantics error: Expected 'name' to be a string but found '\" + type + \"'.\");\n            break;\n        }\n        digraph_.setGraphName(jsonParse.name);\n        \n        type = getType(jsonParse.description);\n        switch (type) {\n        case '[object Undefined]':\n            jsonParse.description = \"\";\n            break;\n        case '[object String]':\n            break;\n        default:\n            error.unshift(\"JSON semantics error: Expected 'description' to be a string but found '\" + type + \"'.\");\n            break;\n        }\n        digraph_.setGraphDescription(jsonParse.description);\n            \n        type = getType(jsonParse.vlist);\n        switch (type) {\n        case '[object Undefined]':\n            jsonParse.vlist = []; // default to empty vertex list\n            break;\n        case '[object Array]':\n            // do nothing the array is parsed below\n            break;\n        default:\n            errors.unshift(\"JSON semantics error: Expected 'vlist' (vertices) to be an array but found '\" + type + \"'.\");\n            break;\n        }\n        if (errors.length) {\n            break;\n        }\n\n        type = getType(jsonParse.elist);\n        switch (type) {\n        case '[object Undefined]':\n            jsonParse.elist = []; // default to empty edge list\n            break;\n        case '[object Array]':\n            // do nothing\n            break;\n        default:\n            errors.unshift(\"JSON semantics error: Expected 'elist' (edges) to be an array but found '\" + type + \"'.\");\n        }\n        if (errors.length) {\n            break;\n        }\n\n        jsonParse.vlist.forEach(processVertex);\n        if (errors.length) {\n            break;\n        }\n\n        jsonParse.elist.forEach(processEdge);\n        if (errors.length) {\n            break;\n        }\n\n    } // while !inBreakScope\n\n    if (errors.length) {\n        response.error = errors.join(' ');\n    } else {\n        response.result = true;\n    }\n\n    return response;\n\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_export.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n// Export the topology and attached vertex and edge properties\n// of a DirectedGraph container object as a JSON-format UTF8 \n// string. This canonical format can be passed as an optional\n// constructor parameter to restore container state across\n// execution contexts.\n\nvar helperFunctions = require('./arc_core_graph_util');\nvar DigraphDataExporter = module.exports = {};\n\nDigraphDataExporter.exportObject = function (digraph_) {\n    var digraphState = {\n        name: digraph_.getGraphName(),\n        description: digraph_.getGraphDescription(),\n        vlist: [],\n        elist: []\n    };\n    var vertexSerialized = {}; // Keep track of the vertices referenced in the edge list.\n    var edgeList = digraph_.getEdges();\n    var vertexList = digraph_.getVertices();\n    digraph_.getEdges().forEach(function(edge_) {\n        var edgeProperty = digraph_.getEdgeProperty(edge_);\n        digraphState.elist.push({ e: edge_, p: edgeProperty });\n        vertexSerialized[edge_.u] = vertexSerialized[edge_.v] = true;\n    });\n    digraph_.getVertices().forEach(function(vertexId_) {\n        var vertexProperty = digraph_.getVertexProperty(vertexId_);\n        var jstype = helperFunctions.JSType(vertexProperty);\n        // If the vertex has an attached property, serialize it to the vlist.\n        if (jstype !== '[object Undefined]') {\n            digraphState.vlist.push({ u: vertexId_, p: vertexProperty });\n        } else {\n            // If the vertex wasn't mentioned in the elist, we need to serialize, sans property, to the vlist.\n            if (vertexSerialized[vertexId_] !== true) {\n                digraphState.vlist.push({ u: vertexId_ });\n            }\n        }\n    });\n    return digraphState;\n};\n\nDigraphDataExporter.exportJSON = function (digraph_, replacer_, space_) {\n    return JSON.stringify(DigraphDataExporter.exportObject(digraph_), replacer_, space_);\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_transpose.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n// transposeDirectedGraph computes the transpose of input digraph_,\n// returns the the result as a new DirectedGraph instance.\n// More info on directed graph transposition:\n// http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/transpose_graph.html\n\nvar helperFunctions = require('./arc_core_graph_util');\nvar DirectedGraph = require('./arc_core_digraph').DirectedGraph;\n\n/*\n  request = DirectedGraph reference\n  response = {\n      error: null or string explaining why result is null\n      result: a new DirectedGraph instance with the same vertex set,\n              the edge set transposed (direction reversed), and vertex\n              and edge properties (if any) linked by reference to the\n              source digraph\n  }\n*/\n\nmodule.exports = function (digraph_) {\n    var response = { error: null, result: null };\n    var errors = [];\n    var innerResponse;\n\n    var digraphOut = new DirectedGraph();\n\n    var jstype = helperFunctions.JSType(digraph_);\n    if (jstype !== '[object Object]') {\n        errors.unshift(\"Expected reference to DirectedGraph but found type '\" + jstype + \"'.\");\n    } else {\n        \n        digraph_.getVertices().forEach(function(vertexId_) {\n            innerResponse = digraphOut.addVertex({ u: vertexId_, p: digraph_.getVertexProperty(vertexId_) });\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n            }\n        });\n\n        digraph_.getEdges().forEach(function(edge_) {\n            innerResponse = digraphOut.addEdge({ e: { u: edge_.v, v: edge_.u }, p: digraph_.getEdgeProperty(edge_) });\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n            }\n        });\n\n    } // end else\n\n    if (errors.length) {\n        errors.unshift(\"jsgraph.directed.transpose failed:\");\n        response.error = errors.join(' ');\n    } else {\n        response.result = digraphOut;\n    }\n    return response;\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_bft.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n/*\n  Inspired by the design of the Boost Graph Library (BGL)\n  http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html\n\n  All visitor callback functions are optional.\n  See also BFS Visitor Concept documentation from the BGL:\n  http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/BFSVisitor.html\n\n  var breadthFirstVisitorInterface = {\n  initializeVertex: function(vertexId_, digraph_),\n  discoverVertex: function(vertexId_, digraph_),\n  startVertex: function(vertexId_, digraph_),\n  examineVertex: function(vertexId_, digraph_),\n  examineEdge: function(vertexIdU_, vertexIdV_, digraph_),\n  treeEdge: function(vertexIdU_, vertexIdV_, digraph_),\n  nonTreeEdge: function(vertexIdU_, vertexIdV_, digraph_),\n  grayTarget: function(vertexIdU_, vertexIdV_, digraph_),\n  blackTarget: function(vertexIdU_, vertexIdV_, digraph_),\n  finishVertex: function(vertexId_, digraph_)\n  };\n\n  request = {\n      digraph: reference to jsgraph.DirectedGraph container object (required)\n      visitor: reference to jsgraph BFV visitor object (required)\n      options: {\n          startVector: reference to a vertex ID string, or an array of vertex ID strings (optional)\n              Note: if ommitted, BFT uses the digraph's root vertex set as the start vertex set\n          signalStart: Boolean flag (optional - default is true if ommitted)\n              Note: By default, BFT will call startVertex on each search root vertex.\n              In advanced scenarios you may wish to override this behavior.\n          traverseContext: reference to BFT search context object (optional)\n              Note: By default, BFT allocates the traversal context internally and returns it to\n              the caller. In advanced scenarios you may wish to provide a pre-initialized\n              (or potentially pre-colored) traversal context object.\n          }\n      }\n  }\n\n  response = {\n      error: null or string explaining why result is null\n      result: BFS search context object\n  }\n*/\n\nvar algorithmName = \"BFT\"; // constant string used in error messages\nvar colors = require('./arc_core_digraph_algorithm_colors');\nvar visitorCallback = require('./arc_core_digraph_algorithm_visit');\nvar normalizeRequest = require('./arc_core_digraph_algorithm_request');\n\n\nmodule.exports = function (request_) {\n\n    var nrequest = null; // normalized request object\n    var response = { error: null, result: null };\n    var errors = [];\n    var continueSearch = true;\n    var inBreakScope = false;\n    var searchQueue = [];\n\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var index, vertexId;\n\n        var innerResponse = normalizeRequest(request_);\n        if (innerResponse.error) {\n            errors.unshift(innerResponse.error);\n            break;\n        }\n        nrequest = innerResponse.result;\n\n        // initializeVertex visitor callback.\n        if (nrequest.options.traverseContext.searchStatus === 'pending') {\n            for (vertexId in nrequest.options.traverseContext.colorMap) {\n                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'initializeVertex', request: { u: vertexId, g: nrequest.digraph }});\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                continueSearch = innerResponse.result;\n                if (!continueSearch) {\n                    break;\n                }\n            }\n        } // if searchStatus 'pending'\n\n        nrequest.options.traverseContext.searchStatus = 'active';\n\n        if (errors.length || !continueSearch) {\n            break;\n        }\n        \n        // Initialize the BF visit or search.\n        // Note that all that distinguishes visit from search is the number of starting vertices. One -> visit, N -> search.\n\n        for (index in nrequest.options.startVector) {\n            var startingVertexId = nrequest.options.startVector[index];\n            // Ensure the starting vertex is in the graph container.\n            if (!nrequest.digraph.isVertex(startingVertexId)) {\n                errors.unshift(\"BFT request failed. Vertex '\" + startingVertexId + \"' not found in specfied directed graph container.\");\n                break;\n            }\n            // Ensure the vertex is white in the color map.\n            if (nrequest.options.traverseContext.colorMap[startingVertexId] !== colors.white) {\n                errors.unshift(\"BFT request failed. Vertex '\" + startingVertexId + \"' color map not initialized to white.\");\n                break;\n            }\n\n            // startVertex visitor callback.\n            if (nrequest.options.signalStart) {\n                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'startVertex', request: { u: startingVertexId, g: nrequest.digraph }});\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                continueSearch = innerResponse.result;\n            }\n            \n            // Conditionally exit the loop if discoverVertex returned false.\n            if (errors.length || !continueSearch) {\n                break;\n            }\n\n            // discoverVertex visitor callback.\n            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'discoverVertex', request: { u: startingVertexId, g: nrequest.digraph }});\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n                break;\n            }\n            continueSearch = innerResponse.result;\n\n            // Remove the vertex from the undiscovered vertex map.\n            delete nrequest.options.traverseContext.undiscoveredMap[startingVertexId];\n\n            // Add the vertex to the search\n            searchQueue.push(startingVertexId);\n\n            // Color the vertex discovered (gray)\n            nrequest.options.traverseContext.colorMap[startingVertexId] = colors.gray;\n\n            // Conditionally exit the loop if discoverVertex returned false.\n            if (!continueSearch) {\n                break;\n            }\n\n        } // for initialize search\n\n        // Execute the main breadth-first algorithm using the starting vertex set as the initial contents of the searchQueue.\n        while (searchQueue.length && continueSearch && !errors.length) {\n\n            vertexId = searchQueue.shift();\n\n            // By convention\n            nrequest.options.traverseContext.colorMap[vertexId] = colors.black;\n\n            // examineVertex visitor callback.\n            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'examineVertex', request: { u: vertexId, g: nrequest.digraph }});\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n                break;\n            }\n            continueSearch = innerResponse.result;\n            if (!continueSearch) {\n                break;\n            }\n\n            var outEdges = nrequest.digraph.outEdges(vertexId);\n\n            for (index in outEdges) {\n\n                var outEdge = outEdges[index];\n\n                // examineEdge visitor callback.\n                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'examineEdge', request: { e: outEdge, g: nrequest.digraph }});\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                continueSearch = innerResponse.result;\n                if (!continueSearch) {\n                    break;\n                }\n\n                var colorV = nrequest.options.traverseContext.colorMap[outEdge.v];\n                switch (colorV) {\n\n                case colors.white:\n                    // discoverVertex visitor callback.\n                    innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'discoverVertex', request: { u: outEdge.v, g: nrequest.digraph }});\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    delete nrequest.options.traverseContext.undiscoveredMap[outEdge.v];\n                    if (!continueSearch) {\n                        break;\n                    }\n                    // treeEdge visitor callback.\n                    innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'treeEdge', request: { e: outEdge, g: nrequest.digraph }});\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    searchQueue.push(outEdge.v);\n                    nrequest.options.traverseContext.colorMap[outEdge.v] = colors.gray;\n                    break;\n\n                case colors.gray:\n                    // nonTreeEdge visitor callback.\n                    innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'nonTreeEdge', request: { e: outEdge, g: nrequest.digraph }});\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    if (continueSearch) {\n                        // grayTarget visitor callback.\n                        innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'grayTarget', request: { e: outEdge, g: nrequest.digraph }});\n                        if (innerResponse.error) {\n                            errors.unshift(innerResponse.error);\n                            break;\n                        }\n                        continueSearch = innerResponse.result;\n                    }\n                    break;\n\n                case colors.black:\n                    // nonTreeEdge visitor callback.\n                    innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'nonTreeEdge', request: { e: outEdge, g: nrequest.digraph }});\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    if (continueSearch) {\n                        // blackTarget visitor callback.\n                        innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'blackTarget', request: { e: outEdge, g: nrequest.digraph }});\n                        if (innerResponse.error) {\n                            errors.unshift(innerResponse.error);\n                            break;\n                        }\n                        continueSearch = innerResponse.result;\n                    }\n                    break;\n\n                default:\n                    errors.unshift(\"BFT failure: An invalid color value was found in the color map for vertex '\" + outEdge.v + \"'. Please file an issue!\");\n                    break;\n\n                } // switch (colorV)\n\n                if (errors.length || !continueSearch) {\n                    break;\n                }\n                \n            } // for (outEdge in outEdges)\n\n            if (errors.length || !continueSearch) {\n                break;\n            }\n\n            // finishVertex visitor callback.\n            innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'finishVertex', request: { u: vertexId, g: nrequest.digraph }});\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n                break;\n            }\n            continueSearch = innerResponse.result;\n            if (!continueSearch) {\n                break;\n            }\n\n        } // while (searchQueue.length)\n\n    } // end while (!inBreakScope)\n\n    if (errors.length) {\n        if (nrequest) {\n            nrequest.options.traverseContext.searchStatus = 'error';\n        }\n        errors.unshift(\"jsgraph.directed.breadthFirstTraverse algorithm failure:\");\n        response.error = errors.join(' ');\n    } else {\n        nrequest.options.traverseContext.searchStatus = continueSearch?'completed':'terminated';\n        response.result = nrequest.options.traverseContext;\n    }\n    return response;\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_colors.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n\n// Encapsule/jsgraph/src/digraph-color.js\n//\n\n// Color ordinals used by directed graph algorithms.\n\nmodule.exports = {\n    white: 0,\n    gray: 1,\n    black: 2\n};\n\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_visit.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\n// Wraps call to DirectedGraph algorithm visitor function callbacks.\n\nvar helperFunctions = require('./arc_core_graph_util');\n\n/*\n  request = {\n      visitor: interface object reference\n      algorithm: string name of the algorithm for error messages\n      method: string name of the visitor method to call\n      request: request object to pass to the visitor method\n  },\n  response = {\n      error: null or string explaining by response.error is null\n      result: null (error) or Boolean flag set true to continue search\n  }\n*/\n\nmodule.exports = function (request_) {\n\n    var response = { error: null, result: null };\n    var errors = [];\n    var inBreakScope = false;\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var visitorCallback = request_.visitor[request_.method];\n        var jstype = helperFunctions.JSType(visitorCallback);\n        // If the visitor function is not defined on the visitor object, return true to continue the search.\n        if (jstype !== '[object Function]') {\n            if (jstype !== '[object Undefined]') {\n                errors.unshift(request_.algorithm + \" visitor interface method '\" + request_.method + \"' is type '\" + jstype + \"' instead of '[object Function]' as expected.\");\n                break;\n            }\n            response.result = true;\n            break;\n        }\n        var continueSearch = visitorCallback(request_.request);\n        jstype = helperFunctions.JSType(continueSearch);\n        if (jstype !== '[object Boolean]') {\n            errors.unshift(request_.algorithm + \" visitor interface error in callback function '\" + request_.method + \"'. Function returned type '\" + jstype + \"' instead of expected '[object Boolean]'.\");\n            break;\n        }\n        response.result = continueSearch;\n    }\n    if (errors.length) {\n        response.error = errors.join(' ');\n    }\n    return response;\n};\n\n\n\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_request.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\nvar helperFunctions = require('./arc_core_graph_util');\nvar TRAVERSE_CONTEXT = require('./arc_core_digraph_algorithm_context');\n\n/*\n  request = {\n      digraph: reference to jsgraph.DirectedGraph container object (required)\n      visitor: reference to jsgraph BFV visitor object (required)\n      options: {\n          startVector: reference to a vertex ID string, or an array of vertex ID strings (optional)\n              Note: if ommitted, BFT uses the digraph's root vertex set as the start vertex set\n          allowEmptyStartVector: Boolean flag (optional - default is false is omitted)\n          signalStart: Boolean flag (optional - default is true if ommitted)\n              Note: By default, BFT will call startVertex on each search root vertex.\n              In advanced scenarios you may wish to override this behavior.\n          traverseContext: reference to BFT search context object (optional)\n              Note: By default, BFT allocates the traversal context internally and returns it to\n              the caller. In advanced scenarios you may wish to provide a pre-initialized\n              (or potentially pre-colored) traversal context object.\n          }\n      }\n  }\n\n  response = {\n      error: null or string explaining why result is null\n      result: Traversal context object or null if error\n  }\n*/\n\nmodule.exports = function (request_) {\n\n    var response = { error: null, result: null };\n    var errors = [];\n    var nrequest = null;\n    var inBreakScope = false;\n\n    var createTraverseContext = function() {\n        var response = TRAVERSE_CONTEXT({ digraph: nrequest.digraph });\n        var result = null;\n        if (response.error) {\n            errors.unshift(response.error);\n        } else {\n            result = response.result;\n        }\n        return result;\n    };\n\n    var getRootVertices = function() {\n        return nrequest.digraph.getRootVertices();\n    };\n        \n    while (!inBreakScope) {\n        inBreakScope = true;\n\n        // Verify the outer shape of the request object.\n        var innerResponse = helperFunctions.JSType(request_);\n        if (innerResponse !== '[object Object]') {\n            errors.unshift(\"Missing request object ~. Found type '\" + innerResponse + \"'.\");\n            break;\n        }\n        nrequest = {};\n        innerResponse = helperFunctions.JSType(request_.digraph);\n        if (innerResponse !== '[object Object]') {\n            errors.unshift(\"Missing required DirectedGraph reference ~.digraph. Found type '\" + innerResponse + \"'.\");\n            break;\n        }\n        nrequest.digraph = request_.digraph;\n        innerResponse = helperFunctions.JSType(request_.visitor);\n        if (innerResponse !== '[object Object]') {\n            errors.unshift(\"Missing required visitor object reference ~.visitor. Found type '\" + innerResponse + \"'.\");\n            break;\n        }\n        \n        nrequest.visitor = request_.visitor;\n        innerResponse = helperFunctions.JSType(request_.options);\n        if ((innerResponse !== '[object Undefined]') && (innerResponse !== '[object Object]')) {\n            errors.unshift(\"Options object ~.options is the wrong type. Found type '\" + innerResponse + \"'.\");\n            break;\n        }\n        nrequest.options = {};\n        if (innerResponse === '[object Object]') {\n            innerResponse = helperFunctions.JSType(request_.options.startVector);\n            switch (innerResponse) {\n            case '[object Undefined]':\n                break;\n            case '[object String]':\n                nrequest.options.startVector = [ request_.options.startVector ];\n                break;\n            case '[object Array]':\n                nrequest.options.startVector = request_.options.startVector;\n                break;\n            default:\n                errors.unshift(\"Options object property ~.options.startVector is the wrong type. Expected either '[object String]', '[object Array]', or '[object Undefined]'. Found type '\" + innerResponse + \"'.\");\n                break;\n            } // end switch\n\n            if (errors.length) {\n                break;\n            }\n\n            innerResponse = helperFunctions.JSType(request_.options.allowEmptyStartVector);\n            if ((innerResponse !== '[object Undefined]') && (innerResponse !== '[object Boolean]')) {\n                errors.unshift(\"Options object property ~.options.allowEmptyStartVector is the wrong type. Expected either '[object Boolean]' or '[object Undefined]. Found type '\" + innerResponse + \"'.\");\n                break;\n            }\n            if (innerResponse == '[object Boolean]') {\n                nrequest.options.allowEmptyStartVector = request_.options.allowEmptyStartVector;\n            }\n\n            innerResponse = helperFunctions.JSType(request_.options.signalStart);\n            if ((innerResponse !== '[object Undefined]') && (innerResponse !== '[object Boolean]')) {\n                errors.unshift(\"Options object property ~.options.signalStart is the wrong type. Expected either '[object Boolean]' or '[object Undefined]'. Found type '\" + innerResponse + \"'.\");\n                break;\n            }\n            if (innerResponse === '[object Boolean]') {\n                nrequest.options.signalStart = request_.options.signalStart;\n            }\n\n\n            innerResponse = helperFunctions.JSType(request_.options.traverseContext);\n            if ((innerResponse !== '[object Undefined]') && (innerResponse !== '[object Object]')) {\n                errors.unshift(\"Options object property ~.options.traverseContext is the wrong type. Expected either '[object Object]' or '[object Undefined']. Found type '\" + innerResponse + \"'.\");\n                break;\n            }\n            if (innerResponse === '[object Object]') {\n                nrequest.options.traverseContext = request_.options.traverseContext;\n            }\n\n        } // end if options object specified\n        \n        helperFunctions.setPropertyValueIfUndefined(nrequest.options, 'startVector', getRootVertices);\n        helperFunctions.setPropertyValueIfUndefined(nrequest.options, 'allowEmptyStartVector', false);\n        helperFunctions.setPropertyValueIfUndefined(nrequest.options, 'signalStart', true);\n        helperFunctions.setPropertyValueIfUndefined(nrequest.options, 'traverseContext', createTraverseContext);\n\n        // Ensure that the starting vertex set is not empty (unless allowed).\n        if (!nrequest.options.startVector.length && !nrequest.options.allowEmptyStartVector) {\n            errors.unshift(\"Traversal aborted because we don't know which vertex to start on. Specify a graph that has at least one root vertex, explicity specify the start vertex (or vertices) via `request.options.startVector` array, or suppress this error by setting `request.options.allowEmptyStartVector` to Boolean true.\");\n            break;\n        }\n\n        response.result = nrequest;\n\n    }\n    if (errors.length) {\n        response.error = errors.join(' ');\n    } else {\n        response.result = nrequest;\n    }\n    return response;\n\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_context.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\nvar helperFunctions = require('./arc_core_graph_util');\nvar colors = require('./arc_core_digraph_algorithm_colors');\n\nmodule.exports = function (request_) {\n    var response = { error: null, result: null };\n    var errors = [];\n    var traverseContext = { searchStatus: 'pending', colorMap: {}, undiscoveredMap: {} };\n    var initializeColorMapRecord = function (vertexId_) {\n        traverseContext.colorMap[vertexId_] = colors.white;\n        traverseContext.undiscoveredMap[vertexId_] = true;\n    };\n    var inBreakScope = false;\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var objectTS = '[object Object]';\n        // Verify request.\n        var type = helperFunctions.JSType(request_);\n        if (type !== objectTS) {\n            errors.unshift(\"Expected request to be of type '\" + objectTS + \"' but found '\" + type + \"'.\");\n            break;\n        }\n        // Verify request.digraph.\n        type = helperFunctions.JSType(request_.digraph);\n        if (type !== objectTS) {\n            errors.unshift(\"Expected request.digraph to be of type '\" + objectTS + \"' but found '\" + type + \"'.\");\n            break;\n        }\n        // Initialize the BFS search context object.\n        request_.digraph.getVertices().forEach(initializeColorMapRecord);\n        // Assign the result. Note that it's incumbant upon the first invocation of\n        // traversal algorithm  to check/set the traverseContext.searchStatus flag and\n        // correctly call the visitor.initializeVertex callback on each vertex in the\n        // color map prior to the start of the search. traverseContext.searchStatus should\n        // be 'running' while a search is in progress. 'terminated' if prematurely terminated\n        // by client visitor code. 'complete' when search concludes normally.\n        response.result = traverseContext;\n    }\n    if (errors.length) {\n        errors.unshift(\"jsgraph.directed.createTraverseContext failed:\");\n        response.error = errors.join(' ');\n    }\n    return response;\n};\n","/home/travis/build/npmtest/node-npmtest-jsgraph/node_modules/jsgraph/src/arc_core_digraph_algorithm_dft.js":"/*\n  Copyright (C) 2014-2016 Christopher D. Russell\n\n  This library is published under the MIT License and is part of the\n  Encapsule Project System in Cloud (SiC) open service architecture.\n  Please follow https://twitter.com/Encapsule for news and updates\n  about jsgraph and other time saving libraries that do amazing things\n  with in-memory data on Node.js and HTML.\n*/\n\nvar algorithmName = \"DFT\"; // used in error messages\nvar colors = require('./arc_core_digraph_algorithm_colors');\nvar visitorCallback = require('./arc_core_digraph_algorithm_visit');\nvar normalizeRequest = require('./arc_core_digraph_algorithm_request');\n\n\nmodule.exports = function (request_) {\n\n    var nrequest = null; // normalized request\n    var response = { error: null, result: null };\n    var errors = [];\n    var continueSearch = true;\n    var inBreakScope = false;\n\n    while (!inBreakScope) {\n        inBreakScope = true;\n        var index, vertexId;\n        var finishedEdges = {};\n        var innerRequest = null;\n        var hash = null;\n\n        var innerResponse = normalizeRequest(request_);\n        if (innerResponse.error) {\n            errors.unshift(innerResponse.error);\n            break;\n        }\n        nrequest = innerResponse.result;\n\n        // initializeVertex visitor callback.\n        if (nrequest.options.traverseContext.searchStatus === 'pending') {\n            for (vertexId in nrequest.options.traverseContext.colorMap) {\n                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'initializeVertex', request: { u: vertexId, g: nrequest.digraph }});\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                continueSearch = innerResponse.result;\n                if (!continueSearch) {\n                    break;\n                }\n            } // end for\n        } // if searchStatus 'pending'\n\n        nrequest.options.traverseContext.searchStatus = 'active';\n\n        if (errors.length || !continueSearch) {\n            break;\n        }\n\n        // Outer depth-first search loop iterates over the start vertex set.\n        for (index in nrequest.options.startVector) {\n\n            vertexId = nrequest.options.startVector[index];\n            \n            // Ensure the starting vertex is actually in the graph.\n            if (!nrequest.digraph.isVertex(vertexId)) {\n                errors.unshift(\"DFT request failed. Vertex '\" + vertexId + \"' not found in specified directed graph container.\");\n                break;\n            }\n\n            // Ensure the starting vertex is undicovered (white in the color map).\n            if (nrequest.options.traverseContext.colorMap[vertexId] !== colors.white) {\n                errors.unshift(\"DFT request failed. Vertex '\" + vertexId + \"' color map not initialized to white.\");\n                break;\n            }\n\n            // startVertex visitor callback\n            if (nrequest.options.signalStart) {\n                innerResponse = visitorCallback({ algorithm: algorithmName, visitor: nrequest.visitor, method: 'startVertex', request: { u: vertexId, g: nrequest.digraph }});\n                if (innerResponse.error) {\n                    errors.unshift(innerResponse.error);\n                    break;\n                }\n                continueSearch = innerResponse.result;\n            }\n            if (!continueSearch) {\n                break;\n            }\n\n            // searchStack is a FILO of FIFO's (or stack of queues if you prefer)\n            // initialized with starting vertex set member under-evaluation's ID.\n            var searchStack = [ [ vertexId ] ]; \n\n            // Iterate until search stack is empty, a client visitor method returns false, or an error occurs.\n            while (searchStack.length && continueSearch && !errors.length) {\n\n                // Peek at the identifier of the vertex at the front of the queue atop the search stack.\n\n                var currentVertexId = (searchStack[searchStack.length - 1])[0];\n\n                switch (nrequest.options.traverseContext.colorMap[currentVertexId]) {\n\n                case colors.white:\n\n                    // Remove the vertex from the undiscovered map.\n                    delete nrequest.options.traverseContext.undiscoveredMap[currentVertexId];\n\n                    // Change the vertex's state to GRAY to record its discovery.\n                    nrequest.options.traverseContext.colorMap[currentVertexId] = colors.gray;\n\n                    // discoverVertex visitor callback.\n                    innerResponse = visitorCallback({\n                        algorithm: algorithmName,\n                        visitor: nrequest.visitor,\n                        method: 'discoverVertex',\n                        request: { u: currentVertexId, g: nrequest.digraph }\n                    });\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    if (!continueSearch) {\n                        break;\n                    }\n\n                    // treeEdge visitor callback.\n                    if (searchStack.length > 1) {\n                        innerResponse = visitorCallback({\n                            algorithm: algorithmName,\n                            visitor: nrequest.visitor,\n                            method: 'treeEdge',\n                            request: { e: { u: searchStack[searchStack.length - 2][0], v: currentVertexId }, g: nrequest.digraph }\n                        });\n                        if (innerResponse.error) {\n                            errors.unshift(innerResponse.error);\n                            break;\n                        } else {\n                            continueSearch = innerResponse.result;\n                            if (!continueSearch) {\n                                break;\n                            }\n                        }\n                    }\n\n                    // Examine adjacent vertices\n                    var vertexOutEdges = nrequest.digraph.outEdges(currentVertexId);\n                    var adjacentVertices = [];\n\n                    while (vertexOutEdges.length && !errors.length && continueSearch) {\n\n                        var adjacentVertexId = vertexOutEdges.shift().v;\n\n                        // examineEdge visitor callback.\n                        innerResponse = visitorCallback({\n                            algorithm: algorithmName,\n                            visitor: nrequest.visitor,\n                            method: 'examineEdge',\n                            request: { e: { u: currentVertexId, v: adjacentVertexId }, g: nrequest.digraph }\n                        });\n                        if (innerResponse.error) {\n                            errors.unshift(innerRepsonse.error);\n                            break;\n                        }\n                        continueSearch = innerResponse.result;\n                        if (!continueSearch) {\n                            break;\n                        }\n\n                        switch (nrequest.options.traverseContext.colorMap[adjacentVertexId]) {\n\n                        case colors.white:\n                            adjacentVertices.push(adjacentVertexId);\n                            break;\n                        case colors.gray:\n                            // backEdge visitor callback.\n                            innerResponse = visitorCallback({\n                                algorithm: algorithmName,\n                                visitor: nrequest.visitor,\n                                method: 'backEdge',\n                                request: { e: { u: currentVertexId, v: adjacentVertexId }, g: nrequest.digraph }\n                            });\n                            if (innerResponse.error) {\n                                errors.unshift(innerResponse.error);\n                            } else {\n                                continueSearch = innerResponse.result;\n                            }\n                            break;\n                        case colors.black:\n                            // forwardOrCrossEdge visitor callback.\n                            innerResponse = visitorCallback({\n                                algorithm: algorithmName,\n                                visitor: nrequest.visitor,\n                                method: 'forwardOrCrossEdge',\n                                request: { e: { u: currentVertexId, v: adjacentVertexId }, g: nrequest.digraph }\n                            });\n                            if (innerResponse.error) {\n                                errors.unshift(innerResponse.error);\n                            } else {\n                                continueSearch = innerResponse.result;\n                            }\n                            break;\n                        }\n                    }\n                    if (adjacentVertices.length) {\n                        searchStack.push(adjacentVertices);\n                    }                                \n\n                    break;\n\n                case colors.gray:\n                    // change the vertex's state to black to indicate search completion.\n                    nrequest.options.traverseContext.colorMap[currentVertexId] = colors.black;\n                    // finishVertex visitor callback.\n                    innerResponse = visitorCallback({\n                        algorithm: algorithmName,\n                        visitor: nrequest.visitor,\n                        method: 'finishVertex',\n                        request: { u: currentVertexId, g: nrequest.digraph }\n                    });\n                    if (innerResponse.error) {\n                        errors.unshift(innerResponse.error);\n                        break;\n                    }\n                    continueSearch = innerResponse.result;\n                    if (!continueSearch) {\n                        break;\n                    }\n                    var inEdgeSet = nrequest.digraph.inEdges(currentVertexId);\n                    while (inEdgeSet.length) {\n                        var inEdge = inEdgeSet.pop();\n                        hash = inEdge.u + inEdge.v;\n                        finishedEdges[hash] = inEdge;\n                    }\n                    searchStack[searchStack.length - 1].shift();\n                    if (!(searchStack[searchStack.length - 1].length)) {\n                        searchStack.pop();\n                    }\n                    break;\n\n                case colors.black:\n\n                    // The black sheep. The only way for a vertex to end up in this state\n                    // is for it to be queued after another adjacent vertex that reaches\n                    // it first in the depth-first search tree. By definition it's already\n                    // been 'finished'. \n\n                    if (searchStack.length > 1) {\n                        innerRequest = { e: { u: (searchStack[searchStack.length - 2])[0], v: currentVertexId }, g: nrequest.digraph };\n                        innerResponse = visitorCallback({\n                            algorithm: algorithmName,\n                            visitor: nrequest.visitor,\n                            method: 'forwardOrCrossEdge',\n                            request: innerRequest\n                        });\n                        if (innerResponse.error) {\n                            errors.unshift(innerResponse.error);\n                            break;\n                        }\n                        continueSearch = innerResponse.result;\n                        if (!continueSearch) {\n                            break;\n                        }\n                    }\n                    searchStack[searchStack.length - 1].shift();\n                    if (!searchStack[searchStack.length - 1].length) {\n                        searchStack.pop();\n                    }\n                    break;\n\n                default:\n                    errors.unshift(\"DFT failure: An invalid color value was found in the color map for vertex '\" + currentVertexId + \"'.\");\n                    break;\n                }\n            } // while search stack is not empty\n\n            if (errors.length || !continueSearch) {\n                break;\n            }\n            \n        } // end while outer depth-first search loop\n\n        if (errors.length || !continueSearch) {\n            break;\n        }\n\n        for (hash in finishedEdges) {\n            innerRequest = { e: finishedEdges[hash], g: nrequest.digraph };\n            innerResponse = visitorCallback({\n                algorithm: algorithmName,\n                visitor: nrequest.visitor,\n                method: 'finishEdge',\n                request: innerRequest\n            });\n            if (innerResponse.error) {\n                errors.unshift(innerResponse.error);\n                break;\n            }\n            continueSearch = innerResponse.result;\n            if (!continueSearch) {\n                break;\n            }\n\n        } // end for\n\n\n    } // while !inBreakScope\n\n    if (errors.length) {\n        if (nrequest) {\n            nrequest.options.traverseContext.searchStatus = 'error';\n        }\n        errors.unshift(\"jsgraph.directed.depthFirstTraverse algorithm failure:\");\n        response.error = errors.join(' ');\n    } else {\n        nrequest.options.traverseContext.searchStatus = continueSearch?'completed':'terminated';\n        response.result = nrequest.options.traverseContext;\n    }\n    return response;\n    \n\n};\n\n"}